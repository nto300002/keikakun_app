# keikakun_app

# keikakun
### **アプリケーション要件定義書: ケイカくん**

**1. アプリケーション概要**

福祉サービス事業所における「個別支援計画」の作成・管理業務をDX化するためのWebアプリケーション。計画の進捗管理を効率化し、更新漏れを防ぐことで、職員の業務負担を軽減し、利用者へのサービス品質向上に貢献する。

**2. ユーザー権限（ロール）**

スタッフは3つの役割に分かれ、それぞれ実行できる操作が異なる。上位の権限を持つスタッフによる「承認フロー」を設けることで、安全な運用を実現する。

| 役割 | `owner` (サービス責任者) | `manager` (マネージャー) | `employee` (一般職員) |
| :--- | :--- | :--- | :--- |
| **主な役割** | アプリ全体の最高責任者。事業所情報とスタッフを管理する。 | 現場の責任者。計画作成の実務とスタッフの作業を監督する。 | 計画作成の実務担当者。 |
| **できること** | ・**全機能の操作**<br>・事業所情報(Office)の作成・更新・削除<br>・全スタッフ(Staff)の権限変更・削除 | ・利用者(WelfareRecipient)の登録・更新・削除<br>・個別支援計画の作成・更新・削除<br>・事業所情報の閲覧 | ・全情報の**閲覧** |
| **制限・承認** | ・自身のデータや事業所の削除には、他の全スタッフの承認が必要。 | ・自身のデータ削除や事業所からの離脱には、`owner`の承認が必要。 | ・利用者や計画の**新規作成・更新・削除**には、`manager`以上の承認が必要。 |

---

**3. 主要機能と画面フロー**

**3.1. 認証と利用開始フロー**

登録方法によって初期の役割（ロール）が決定される。

*   **一般職員 (`employee`)**: 事業所IDが含まれたURL(`/auth/signup`)からサインアップ。
*   **マネージャー (`manager`)**: 事業所IDが含まれたURL(`/auth/signup`)からサインアップ。
*   **サービス責任者 (`owner`)**: 専用の管理者登録URL (`/admin/signup`) からサインアップ。責任者はログイン後、まず事業所情報を作成する必要がある(admin/setup)。

**3.2. ダッシュボード (`/dashboard`)**

*   **目的**: ログイン後のトップページ。担当する利用者の計画状況を一覧で把握する。
*   **表示項目**:
    *   ログイン中のスタッフ名、役割、権限の説明。
    *   **利用者一覧テーブル**:
        *   **氏名**: 利用者のフルネーム。クリックで個別支援計画ページへ遷移。
        *   **計画の進捗**: 現在の計画が何サイクル目で、どのステップ（アセスメント、原案作成など）にいるか。
        *   **次回更新日**: 計画の更新期限日と、今日からの残り日数。
        *   **モニタリング期限**: モニタリングが必要な場合の期限と、残り日数。
        *   **詳細情報**: リンク(`individual_support_plan, assessment, pdf_list`),利用者の更新,削除
*   **主な機能**:
    *   利用者の新規登録（承認フローあり）。
    *   モニタリング期限の設定。

**3.3. 個別支援計画ページ (`/individual_support_plan`)**

*   **目的**: 特定の利用者一人に絞り、計画の全サイクルと各ステップの進捗を管理する。
*   **表示項目**:
    *   **計画サイクルテーブル**: 過去から現在までの全計画サイクルを行として表示。
        *   **列**: 回数、アセスメント/モニタリング、計画書(原案)、担当者会議、計画書(署名済)
        *   **セル**: 各ステップの完了状況（チェックボックス等）と、成果物（PDF）へのリンク。
*   **主な機能**:
    *   各ステップの成果物（PDF）をアップロード/更新/削除する。
    *   **処理ロジック（バックエンド）**:
        1.  **ステップの順守**: 必ず「アセスメント→原案作成→...」の順にしか完了できず、ステップを飛ばすことはできない。
        2.  **PDFと進捗の連動**: 成果物PDFがアップロードされると、対応するステップが自動的に「完了」となる。
        3.  **新サイクルの自動生成**: 「計画書(署名済)」がアップロードされると、現在のサイクルが完了したとみなし、次の新しい計画サイクル（モニタリングから開始）が自動的に作成される。
        4. **期限通知** 
        - **全体更新**: 残り1ヶ月になったら通知  期限過ぎの場合も 期限が過ぎていますと表示
        - **モニタリング**: 新しいサイクルができた時点で通知　期限過ぎの場合　期限が過ぎていますと表示 モニタリング期限ボタンで期限を設定(default=7)
        - **通知の方法**: googleアカウントをページ内に登録し、イベントIDなどを通じてgoogleカレンダーに通知が届く　アプリヘッダーのベルマークをクリックすることでも通知を確認できる (デスクトップ、スマホ上の通知)
*   **課題・要検討事項**:
    *   署名済みPDFを再アップロードした場合に、計画サイクルが意図せず重複して作成されてしまう問題を防止するロジックが必要。


**3.4. その他の主要ページ**

| ページ名 | URL | 役割 |
| :--- | :--- | :--- |
| **事務所管理** | `/admin/office_management` | (`owner`のみ) スタッフの権限変更、事業所情報の編集 |
| **プロフィール** | `/profile` | 自身の登録情報（名前、メール）の編集、権限変更の申請|申請結果、事業所からの退会申請を行う。認証機能の追加(MFA) |
| **PDF一覧** | `/pdf_list` | アップロードした全てのアセスメントシートや計画書を一覧で確認・閲覧する。 |
| **アセスメントシート** | `/assessment` | (notMVP) アセスメントシートのPDFをアップロード・管理する。 (将来的にフォーム化) |

## UI
- PWA化
- ダークモードをデフォルトで設定
- 

---

**4. 外部サービス連携**

**4.1. Googleカレンダー連携**

*   **目的**: 計画の更新期限を自動でGoogleカレンダーに登録し、チーム全体での見落としを防ぐ。
*   **トリガー**: バックエンドで計画の「次回更新期限」が確定したタイミング。
*   **処理**:
    1.  GoogleカレンダーAPIを呼び出し、指定されたカレンダーにイベントを作成。
    2.  APIから返された**イベントID**と**イベントURL**をデータベース (`SupportPlanCycle`テーブル) に保存する。
    3.  もし計画日が変更された場合は、保存したイベントIDを使ってカレンダー上のイベントを更新する。

---

**5. データベースモデル**

*   **`Staff`, `Office`, `OfficeStaff`**: スタッフと事業所の「多対多」の関係を管理。
*   **`WelfareRecipient`, `Office`, `OfficeWelfareRecipient`**: 利用者と事業所の「多対多」の関係を管理。
*   **`SupportPlanCycle`**: 利用者一人の計画1サイクル（約6ヶ月）を管理する中核モデル。
*   **`SupportPlanStatus`**: 1つのサイクル内の各ステップ（アセスメント、モニタリング等）の進捗を管理。
*   **`PlanDeliverable`**: 各ステップでアップロードされた成果物（PDF）の情報を管理。
*   **`Notice`**: アプリ内の各種通知（承認依頼など）を管理。
*   **`RoleChangeRequest`**: スタッフからの権限変更申請の履歴を管理。
---

---

### **1. 決済機能の要件定義**

**1.1. 課金モデル**

*   **料金体系**:
    *   **月額 3,000円** のサブスクリプションモデル。
    *   この料金で、**最大10人**の利用者（`WelfareRecipient`）を登録・管理可能。
*   **課金単位**:
    *   課金は事業所（`Office`）ごとに行われます。
    *   1つの事業所が複数のプランを契約することはできません。基本は1事業所1契約です。
*   **課金トリガー**:
    *   事業所に所属するアクティブな利用者数が**10人に達した状態で、11人目を登録しようとした瞬間**に、課金（サブスクリプション登録）が要求されます。
    *   すでに課金中の事業所は、利用者数に関わらず、毎月自動で請求が発生します。

**1.2. 必要なライブラリ・サービス**

*   **決済代行サービス**: **Stripe**
    *   **理由**: 豊富な機能、優れた開発者向けドキュメント、セキュアな決済処理、サブスクリプション管理機能など、今回の要件に最適なため。
*   **バックエンドライブラリ**: `stripe` (`^9.0.0` or later)
    *   FastAPIからStripeのAPIを呼び出すための公式Pythonクライアント。
*   **フロントエンドライブラリ**: `@stripe/stripe-js`, `@stripe/react-stripe-js`
    *   Reactアプリケーションに、セキュアなクレジットカード入力フォーム（Stripe Elements）や決済処理機能を組み込むための公式ライブラリ。

**1.3. 決済フロー**

1.  **課金画面への誘導**:
    *   事業所の利用者数が10人の状態で、フロントエンドの「利用者作成ボタン」を押す、または利用者作成APIを呼び出す。
    *   バックエンドはAPIリクエストを受け取った際、現在の利用者数と課金状況をチェックし、「要課金」と判断した場合、`402 Payment Required`というステータスコードとエラーメッセージを返す。
    *   フロントエンドは`402`ステータスコードを受け取り、ユーザーを自動的に決済ページ（`/office_management`）にリダイレクトする。

2.  **サブスクリプション登録 (Stripe Checkout)**:
    *   **バックエンド**:
        1.  決済ページが表示される際、フロントエンドはバックエンドに「決済セッション作成」をリクエストする。
        2.  バックエンドはStripe APIを呼び出し、**Stripe Checkoutセッション**を作成します。このセッションには、料金プランIDや成功時・キャンセル時のリダイレクト先URLが含まれます。
        3.  作成されたセッションIDをフロントエンドに返します。
    *   **フロントエンド**:
        1.  受け取ったセッションIDを使い、Stripe.jsの`redirectToCheckout`関数を呼び出します。
        2.  ユーザーはStripeがホストする安全な決済ページにリダイレクトされ、そこでカード情報などを入力します。

3.  **決済完了とステータス同期**:
    *   ユーザーが決済を完了すると、Stripeはバックエンドの指定した**Webhookエンドポイント**に`checkout.session.completed`というイベントを送信します。
    *   **バックエンド (Webhookハンドラ)**:
        1.  Webhookリクエストの署名を検証し、Stripeからの正当なリクエストであることを確認します。
        2.  イベントのペイロードから`customer_id`（顧客ID）と`subscription_id`（サブスクリプションID）を取得します。
        3.  これらのIDを、事業所モデル（`Office`）の新しいカラム（例: `stripe_customer_id`, `stripe_subscription_id`）に保存します。
        4.  事業所の課金ステータス（例: `billing_status`）を`'active'`（課金中）に更新します。
    *   ユーザーはフロントエンドの決済成功ページにリダイレクトされ、「登録が完了しました」といったメッセージが表示されます。

**1.4. 必要なデータベースモデルの変更**

`Office`テーブルに、Stripeの情報を紐付けるためのカラムを追加します。

```python
# app/models/office.py の Office モデル
class BillingStatus(enum.Enum):
    free = 'free'          # 無料プラン
    active = 'active'        # 課金中
    past_due = 'past_due'    # 支払い延滞
    canceled = 'canceled'    # キャンセル済み

class Office(Base):
    # ... 既存のカラム ...
    name: Mapped[str]
    

    billing_status: Mapped[BillingStatus] = mapped_column(
        SQLAlchemyEnum(BillingStatus), default=BillingStatus.free, nullable=False
    )
    stripe_customer_id: Mapped[Optional[str]] = mapped_column(String(255), unique=True)
    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(String(255), unique=True)
 
```

---

### **2. 更新された要件定義書への反映**

以下に、既存の要件定義書に上記の決済機能要件を組み込んだものを示します。

**(主要機能と画面フローのセクションに追記)**

**3.5. 決済・請求管理ページ (`/office/billing`)**

*   **目的**: 事業所の課金ステータスを確認し、決済手続きを行う。
*   **アクセス条件**:
    *   利用者数が上限に達し、追加登録時に自動でリダイレクトされる。->`owner`のみ
    *   `owner`が事務所管理ページから遷移する。
    * それ以外のロールでは警告が出る => `利用上限のお知らせ(...上記要件をまとめた文)をサービス管理者にお知らせください`
*   **表示項目**:
    *   現在のプラン（無料プラン / 月額3,000円プラン）。
    *   現在の登録利用者数 / 上限利用者数 (例: `8 / 10人`)。
    *   課金ステータス（課金中, 支払い延滞など）。
    *   **Stripeカスタマーポータルへのリンク**: 登録済みのユーザーが、支払い方法の変更や請求書の確認、サブスクリプションの解約を行うためのStripe提供ページへのリンク。
*   **主な機能**:
    *   **サブスクリプション登録**: Stripe Checkoutを利用した決済フローを開始する。

**(開発方針・技術メモのセクションに追記)**

**8. 決済処理**

*   **決済代行サービス**: **Stripe**を利用する。
*   **フロー**:
    *   利用者数が上限（10人）に達した場合、バックエンドは`402 Payment Required`を返し、フロントエンドは決済ページへリダイレクトする。
    *   決済処理は、安全な**Stripe Checkout**ページにリダイレクトして行う。
    *   決済完了後のステータス同期は、**Stripe Webhook**を用いて非同期で実行する。バックエンドはWebhookの署名を必ず検証する。
*   **データモデル**: `Office`モデルに`billing_status`、`stripe_customer_id`、`stripe_subscription_id`のカラムを追加し、Stripeの顧客・契約情報と紐付ける。
---

**6. UI/UX要件**

*   **ダークモード**: 目の負担を軽減するダークモードに対応する。
*   **PWA化**: スマートフォンでもネイティブアプリのように快適に利用できるよう、PWA（Progressive Web App）に対応する。

---

**7. 開発方針・技術メモ**

*   **アーキテクチャ**: フロントエンド(Next.js)とバックエンド(FastAPI)を分離し、`gitmodules`でリポジトリを管理。
*   **バックエンド責務**:
    *   **エンドポイント層**: リクエストの受付とレスポンスの返却。サービス層を呼び出す。
    *   **サービス層**: 複数のCRUD処理を組み合わせ、一つのビジネスロジック（機能）を実装する。
    *   **CRUD層**: データベースに対する基本的なデータ操作（作成, 読込, 更新, 削除）を担う。
*   **データベース**: SQLAlchemyの`selectinload`/`joinload`を適切に使い分け、N+1問題を回避しクエリパフォーマンスを最適化する。
*   **CI/CD**: 開発の早い段階でデプロイの自動化パイプラインを構築する。
*   **インフラ**: 運用費用を抑えるため、サーバーレスやPaaSなどの安価なクラウドサービスを積極的に利用する。

```
keikakun_front/
├── .git/
├── .next/
├── app/
│   ├── (auth-pages)/
|   |   ├── admin/signup/
│   │   ├── e-mail_authentication/
│   │   ├── reset-password/
│   │   ├── [office_id]/signup/
│   │   └── /login
|   |
│   ├── api/
│   ├── components/
│   │   ├── hotbar.tsx
│   │   ├── staff/
│   │   ├── office/
│   │   ├── welfare_recipient/
│   │   ├── support_plan_cycle/
│   │   ├── support_plan_status/
│   │   ├── plan_deliverable/
│   │   ├── notice/
│   │   ├── role_change_request/
│   │   └── ui/
│   ├── [recipient_id]/ --/individual_support_plan --/assessment --/pdf_list
│   ├── admin/
|   |     ├── office_management/
|   |     └── setup/
│   ├── dashboard/
│   ├── recipients/ --/edit --/new
│   ├── profile/ --/edit
│   ├── style/
│   ├── favicon.ico
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   └── ui/
├── lib/
│   ├── api/
│   │   ├── auth/
│   │   ├── support_plan.ts
│   │   ├── getStaffProfile.ts
│   │   ├── recipient.ts
│   │   ├── dashboard.ts
│   │   └── checkStaffProfile.ts
│   ├── transformers/
│   ├── supportPlanUtils.ts
│   ├── utils.ts
│   ├── errorMessages.ts
│   └── validate.ts
├── types/
├── utils/
│   └── supabase/
├── supabase/
├── test/
├── public/
├── node_modules/
├── package.json
├── package-lock.json
├── middleware.ts
├── tailwind.config.ts
├── components.json
├── next.config.js
├── next-env.d.ts
├── tsconfig.json
├── type.ts
├── postcss.config.js
├── jest.config.js
├── .eslintrc.json
├── .gitignore
└── README.md
```


```
keikakun_api/
├── .git/
├── app/
│   ├── api/
│   │   ├── v1/
│   │   │   ├── endpoints/
│   │   │   │   ├── support_plan.py
│   │   │   │   ├── service_offices.py
│   │   │   │   ├── user_password.py
│   │   │   │   ├── login.py
│   │   │   │   ├── service_recipient.py
│   │   │   │   ├── staff.py
│   │   │   │   └── __init__.py
│   │   │   ├── control_authority.py
│   │   │   ├── api.py
│   │   │   └── __init__.py
│   │   ├── deps.py
│   │   └── __init__.py
│   ├── auth/
│   ├── core/
│   ├── crud/
│   ├── db/
│   ├── models/
│   │   ├── staff.py
│   │   ├── support_plan.py
│   │   ├── service_recipient.py
│   │   ├── base.py
│   │   ├── admin_staff_details.py
│   │   ├── permission.py
│   │   ├── role_change_request.py
│   │   ├── service_office.py
│   │   ├── enums.py
│   │   └── __init__.py
│   ├── schemas/
│   ├── services/
│   ├── main.py
│   ├── exceptions.py
│   └── __init__.py
├── migration/
│   ├── versions/
│   ├── env.py
│   ├── script.py.mako
│   └── README
├── tests/
├── supabase/
├── .pytest_cache/
├── .vscode/
├── __pycache__/
├── requirements.txt
├── requirements-dev.txt
├── requirements.in
├── requirements-dev.in
├── pytest.ini
├── alembic.ini
├── Dockerfile
├── .gitignore
└── README.md
```

## 他要件
- コーディング規約
- apiの責務(endpoints, crud, serveces): 具体的なコード例と、メソッドのインポート方法、crudメソッド、サービスメソッドの呼び出し方

2. バックエンドにおける各層の責務定義
品質と保守性の高いコードを維持するため、各層の役割を以下のように厳格に定義する。
- api 層 (エンドポイント)
責務: HTTPリクエストの受付とレスポンスの返却、認証・認可、リクエスト内容の検証。対応するservices層のメソッドを呼び出す。
禁止事項: ビジネスロジックの実装、crud層の直接呼び出し。
- services 層 (ビジネスロジック)
責務: アプリケーション固有のユースケースを実装する。複数のcrud処理を組み合わせ、一連のビジネスプロセスを構成する。トランザクション管理。
禁止事項: データベースのテーブル構造に直接依存した処理。
- crud 層 (データベースアクセス)
責務: 単一のモデル（テーブル）に対する、基本的なCRUD（作成, 読込, 更新, 削除）操作のみを提供する。
禁止事項: ビジネスロジックの実装、複数のモデルにまたがる複雑な更新。
- schemas 層 (データ構造定義)
責務: APIの入出力や層間でデータをやり取りするための厳格なデータ構造（DTO）をPydanticを用いて定義する。
禁止事項: バリデーション以外のロジックの実装。
3. コーディング規約：インポートルール
- crud層の呼び出し: services層からcrud層のメソッドを呼び出す際は、必ずfrom app import crudとしてトップレベルのパッケージをインポートし、crud.crud_オブジェクト名.メソッド()の形式で呼び出す。これにより、モジュールの依存関係を一元管理し、循環参照を防止する。
- 一方向の依存: api → services → crudという一方向の依存関係を徹底する。逆方向のインポートは禁止する。


-
---
## フロントエンド (Next.js)
| ライブラリ名                      | 推奨バージョン                 | 内容・役割                                                                       |
| :-------------------------- | :---------------------- | :-------------------------------------------------------------------------- |
| **`next`**                  | `^15.3.5`               | **フレームワーク**: Reactの主要フレームワーク。App Router、サーバーコンポーネント、ファイルベースルーティングなどを提供。     |
| **`react`**                 | `^19.1.0`               | **UIライブラリ**: ユーザーインターフェースを構築するためのコアライブラリ。                                   |
| **`react-dom`**             | `^19.1.0`               | **UIライブラリ**: ReactをブラウザのDOMに描画するためのライブラリ。                                   |
| **`tailwindcss`**           | `^4.1.11`               | **CSSフレームワーク**: ユーティリティファーストのアプローチで、効率的にUIをデザインする。                          |
| **`shadcn-ui`**             | `^0.9.5`                | **UIコンポーネント**: Tailwind CSSベースの美しくアクセシブルなUIコンポーネント群。コピー＆ペーストでプロジェクトに導入できる。  |
| **`@tanstack/react-query`** | `^5.82.0`               | **データ取得・状態管理**: サーバーからのデータ取得、キャッシュ、非同期状態の管理を宣言的に行う。SWRと人気を二分するが、より高機能。      |
| **`react-hook-form`**       | `^7.60.0`               | **フォーム管理**: パフォーマンスが高く、柔軟なフォームの状態管理とバリデーションを実現する。                           |
| **`zod`**                   | `^4.0.5`                | **スキーマ検証**: TypeScriptファーストのスキーマ定義・検証ライブラリ。フォームの入力値やAPIレスポンスの型を安全に検証できる。    |
| **`axios`**                 | `^1.10.0`               | **HTTPクライアント**: `fetch` APIのラッパー。リクエスト/レスポンスのインターセプト、タイムアウト設定など、より高度な機能を提供。 |
| **`date-fns`**              | `^4.1.0`                | **日付操作**: 軽量でモダンな日付操作ライブラリ。「残り日数」の計算や日付のフォーマットに利用。                          |
| **`lucide-react`**          | `^0.525.0`              | **アイコン**: シンプルで美しいアイコンセット。shadcn/uiと親和性が高い。                                 |
| **`@supabase/supabase-js`** | `^2.50.5`               | **Supabaseクライアント**: Supabaseの認証やDB操作をフロントエンドから安全に行うための公式ライブラリ。              |
| **`typescript`**            | `^5.8.3`                | **言語**: JavaScriptに静的な型付けを追加し、コードの堅牢性を高める。                                  |
| **`eslint` / `prettier`**   | 最新 (`^9.30.1`/`^3.6.2`) | **リンター/フォーマッター**: コードの品質を保ち、チーム内でのスタイルを統一するための必須ツール。                        |

---

## バックエンド (FastAPI)

| ライブラリ名                         | 推奨バージョン    | 内容・役割                                                                        |
| :----------------------------- | :--------- | :--------------------------------------------------------------------------- |
| **`fastapi`**                  | `^0.116.0` | **フレームワーク**: Pythonの主要な非同期Webフレームワーク。高性能で、依存性注入や自動APIドキュメント生成が特徴。            |
| **`uvicorn`**                  | `^0.35.0`  | **ASGIサーバー**: FastAPIアプリケーションを実行するための、軽量で高速なサーバー。                            |
| **`sqlalchemy`**               | `^2.0.41`  | **ORM**: Pythonでデータベースをオブジェクト指向的に操作するためのライブラリ。非同期サポートが強化されている。               |
| **`asyncpg`**                  | `^0.30.0`  | **DBドライバ**: SQLAlchemyが非同期でPostgreSQL（Supabase）と通信するために必要な、高性能なデータベースドライバ。   |
| **`alembic`**                  | `^1.16.4`  | **DBマイグレーション**: SQLAlchemyのモデル定義の変更を検出し、データベーススキーマを安全に更新するための必須ツール。          |
| **`pydantic`**                 | `^2.11.7`  | **データ検証**: FastAPIの根幹をなすデータ検証ライブラリ。APIの入出力（スキーマ）を厳格に定義・検証する。                 |
| **`pydantic-settings`**        | `^2.10.1`  | **設定管理**: `.env`ファイルなどから環境変数を型安全に読み込み、アプリケーションの設定を管理する。                      |
| **`python-jose`**              | `^3.5.0`   | **JWT操作**: JWT（JSON Web Token）のエンコード・デコードを行う。Supabase Authや独自の認証処理で使用。       |
| **`passlib`**                  | `^1.7.4`   | **ハッシュ化**: パスワードなどのハッシュ化と検証を行うライブラリ。`bcrypt`アルゴリズムのサポートも含む。                  |
| **`google-api-python-client`** | `^2.176.0` | **Google APIクライアント**: GoogleカレンダーAPIなどと連携するための公式ライブラリ。                       |
| **`google-auth-oauthlib`**     | `^1.2.2`   | **Google認証**: OAuth 2.0フローを実装し、ユーザーの代わりにGoogle APIへのアクセス許可を得るために使用。          |
| **`httpx`**                    | `^0.28.1`  | **非同期HTTPクライアント**: `requests`ライブラリの非同期版。サービス層から外部API（Googleなど）を非同期で呼び出す際に使用。 |
| **`supabase` (Python)†**       | `^2.16.0`  | **Supabaseクライアント (管理用)**: バックエンドからSupabaseのAdmin権限（ユーザー招待など）を操作するための公式ライブラリ。 |
| **`python-multipart`**         | `^0.0.20`  | **ファイルアップロード**: FastAPIでファイルアップロード（`UploadFile`）を扱うために必要。                    |
| **`pytest`**                   | `^8.4.1`   | **テストフレームワーク**: Pythonのデファクトスタンダードなテストフレームワーク。                               |
| **`pytest-asyncio`**           | `^1.0.0`   | **非同期テスト**: `pytest`で`async def`のテストケースを実行するために必要。                           |

---

Last updated: 2025-11-21
Last updated: 2025-11-24 11:47