# デプロイ時の整合性を保つための原則

**作成日**: 2026-02-10
**対象**: けいかくん（個別支援計画管理システム）
**目的**: 本番環境へのデプロイで整合性を保つための考え方を言語化

---

## 🎯 デプロイの基本原則

### デプロイとは何か

デプロイは、**稼働中のシステムに変更を加える行為**です。

```
デプロイ前の状態                デプロイ後の状態
┌─────────────┐                ┌─────────────┐
│   v1.0      │                │   v1.1      │
│             │   デプロイ      │             │
│ 実行中      │  ────────→     │ 実行中      │
│             │                │             │
│ ユーザー    │                │ ユーザー    │
│ アクセス中  │                │ アクセス中  │
└─────────────┘                └─────────────┘

この間、以下を維持する必要がある：
1. サービスの継続性（ダウンタイムなし）
2. データの整合性（データ破損なし）
3. ユーザー体験の一貫性（エラーなし）
```

**整合性**とは：
- システムの各コンポーネントが矛盾なく動作する状態
- データが正確で一貫している状態
- ユーザーが期待通りの動作を得られる状態

---

## 📋 デプロイ時に意識すべき7つの整合性

### 1. データベースの整合性

#### 1.1 スキーマの整合性

**問題**: アプリケーションコードとDBスキーマの不整合

```python
# デプロイ前のコード
class User:
    email: str
    password: str

# デプロイ後のコード（新カラム追加）
class User:
    email: str
    password: str
    phone_number: str  # ← 新規追加
```

**整合性を保つための原則**:

```
原則1: "後方互換性のあるマイグレーション"
┌─────────────────────────────────────────────┐
│                                             │
│  ステップ1: カラム追加（NULL許可）          │
│  ALTER TABLE users ADD COLUMN phone_number  │
│                                             │
│  ステップ2: アプリケーションデプロイ        │
│  → 新カラムを使い始める                    │
│                                             │
│  ステップ3: データ移行（バッチ処理）        │
│  → 既存レコードにデフォルト値を設定        │
│                                             │
│  ステップ4: NOT NULL制約追加（次回デプロイ）│
│  ALTER TABLE users ALTER COLUMN             │
│    phone_number SET NOT NULL                │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの適用例**:

```python
# ❌ 悪い例（整合性が壊れる）
# マイグレーション
ALTER TABLE staffs ADD COLUMN department VARCHAR(100) NOT NULL;

# 問題: 既存レコードはNOT NULL制約違反でエラー


# ✅ 良い例（整合性を保つ）
# ステップ1: マイグレーション（NULL許可）
ALTER TABLE staffs ADD COLUMN department VARCHAR(100);

# ステップ2: デプロイ（新カラムを使用開始）
class Staff:
    department: Optional[str] = None  # NULL許可

# ステップ3: バッチ処理でデータ移行
UPDATE staffs SET department = 'general' WHERE department IS NULL;

# ステップ4: 次回デプロイでNOT NULL化
ALTER TABLE staffs ALTER COLUMN department SET NOT NULL;
```

---

#### 1.2 データの整合性

**問題**: カラム削除による既存データの喪失

```python
# デプロイ前
class Staff:
    email: str
    old_field: str  # 削除予定

# デプロイ後
class Staff:
    email: str
    # old_field を削除
```

**整合性を保つための原則**:

```
原則2: "段階的な削除（Deprecation）"
┌─────────────────────────────────────────────┐
│                                             │
│  フェーズ1: 使用停止（3ヶ月）                │
│  - コードから参照を削除                     │
│  - カラムは残す（データ保持）               │
│                                             │
│  フェーズ2: 削除警告（1ヶ月）               │
│  - ログに警告を出力                        │
│  - ドキュメント更新                        │
│                                             │
│  フェーズ3: 物理削除                        │
│  - ALTER TABLE DROP COLUMN                  │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの適用例**:

```python
# ❌ 悪い例（データ喪失）
# いきなりカラム削除
ALTER TABLE staffs DROP COLUMN old_email;


# ✅ 良い例（段階的削除）
# フェーズ1: コードから参照を削除（カラムは残す）
class Staff:
    email: str
    # old_email: str  # コメントアウト（削除予定）

# フェーズ2: 3ヶ月後、物理削除
ALTER TABLE staffs DROP COLUMN old_email;
```

---

### 2. API互換性の整合性

#### 2.1 後方互換性

**問題**: APIレスポンス形式の変更によるフロントエンドの破壊

```python
# デプロイ前のAPI
{
    "id": "123",
    "name": "田中太郎"
}

# デプロイ後のAPI（破壊的変更）
{
    "id": "123",
    "full_name": "田中太郎"  # ← nameからfull_nameに変更
}
```

**整合性を保つための原則**:

```
原則3: "後方互換性のあるAPI変更"
┌─────────────────────────────────────────────┐
│                                             │
│  ステップ1: 新フィールド追加（既存は維持）  │
│  {                                          │
│    "id": "123",                             │
│    "name": "田中太郎",      ← 維持          │
│    "full_name": "田中太郎"  ← 新規追加      │
│  }                                          │
│                                             │
│  ステップ2: フロントエンド移行期間（3ヶ月） │
│  - 新フィールドへの移行を促す              │
│                                             │
│  ステップ3: 旧フィールド削除（次回メジャー）│
│  - APIバージョンアップ（v1 → v2）          │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの適用例**:

```python
# ❌ 悪い例（フロントエンドが壊れる）
@router.get("/api/v1/users/{user_id}")
async def get_user(user_id: UUID):
    return {
        "id": str(user_id),
        "full_name": user.full_name  # nameから変更
    }


# ✅ 良い例（後方互換性を保つ）
@router.get("/api/v1/users/{user_id}")
async def get_user(user_id: UUID):
    return {
        "id": str(user_id),
        "name": user.full_name,       # 旧フィールド（維持）
        "full_name": user.full_name   # 新フィールド（追加）
    }

# 将来的にv2で旧フィールド削除
@router.get("/api/v2/users/{user_id}")
async def get_user_v2(user_id: UUID):
    return {
        "id": str(user_id),
        "full_name": user.full_name   # 新フィールドのみ
    }
```

---

#### 2.2 フロントエンドとの同期

**問題**: バックエンドとフロントエンドのデプロイタイミングのズレ

```
タイムライン:
10:00 - バックエンドデプロイ（新API）
10:05 - フロントエンドデプロイ待ち
        ↓
        この5分間、フロントエンドは旧コードで新APIを呼び出す
        → エラー発生
```

**整合性を保つための原則**:

```
原則4: "デプロイ順序の制御"
┌─────────────────────────────────────────────┐
│                                             │
│  パターンA: バックエンド先行デプロイ        │
│  1. バックエンドデプロイ（後方互換性あり）  │
│  2. フロントエンドデプロイ                  │
│  → 安全（旧フロントエンドでも動作）        │
│                                             │
│  パターンB: フロントエンド先行デプロイ      │
│  1. フロントエンドデプロイ                  │
│  2. バックエンドデプロイ                    │
│  → 危険（新フロントエンドが旧APIに依存）   │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの推奨順序**:

```bash
# ✅ 推奨デプロイ順序
1. バックエンドデプロイ（後方互換性あり）
   → GitHub Actions: cd-backend.yml

2. 動作確認（5-10分）
   → 既存フロントエンドで動作確認

3. フロントエンドデプロイ
   → GitHub Actions: cd-frontend.yml
```

---

### 3. 環境変数・設定の整合性

#### 3.1 環境変数の追加

**問題**: 新しい環境変数が設定されていない

```python
# デプロイ後のコード
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

# しかし、Cloud Runに環境変数が設定されていない
# → KeyError または None
```

**整合性を保つための原則**:

```
原則5: "環境変数の事前設定"
┌─────────────────────────────────────────────┐
│                                             │
│  ステップ1: デプロイ前に環境変数を設定      │
│  gcloud run services update k-back \        │
│    --update-env-vars NEW_VAR=value          │
│                                             │
│  ステップ2: 設定確認                        │
│  gcloud run services describe k-back        │
│                                             │
│  ステップ3: アプリケーションデプロイ        │
│  → 環境変数が既に存在                      │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの適用例**:

```python
# ❌ 悪い例（エラーになる）
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")
# → デプロイ直後はNone、エラー発生


# ✅ 良い例（デフォルト値とバリデーション）
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")

if not STRIPE_WEBHOOK_SECRET:
    logger.warning("STRIPE_WEBHOOK_SECRET is not set")
    # 開発環境ではダミー値を使用
    if os.getenv("ENVIRONMENT") == "development":
        STRIPE_WEBHOOK_SECRET = "dummy_secret"
    else:
        raise ValueError("STRIPE_WEBHOOK_SECRET must be set in production")
```

---

#### 3.2 cloudbuild.yml の整合性

**問題**: cloudbuild.yml に新しい環境変数の設定を忘れる

```yaml
# cd-backend.yml に追加されているが
--substitutions=_NEW_VAR="${{ secrets.NEW_VAR }}"

# cloudbuild.yml に追加されていない
##NEW_VAR=${_NEW_VAR}  # ← 忘れている
```

**整合性を保つための原則**:

```
原則6: "設定ファイルの同期"
┌─────────────────────────────────────────────┐
│                                             │
│  チェックリスト:                            │
│  □ cd-backend.yml に追加                    │
│  □ cloudbuild.yml に追加                    │
│  □ GitHub Secrets に追加                    │
│  □ .env.example に追加（ドキュメント用）    │
│                                             │
└─────────────────────────────────────────────┘
```

---

### 4. 実行中のリクエストへの影響

#### 4.1 インフライトリクエストの処理

**問題**: デプロイ時に実行中のリクエストが中断される

```
ユーザーがフォーム送信
    ↓
リクエスト処理中（3秒）
    ↓ ← この時にデプロイ
Cloud Runが旧インスタンスを即座にシャットダウン
    ↓
リクエストが中断され、エラー
```

**整合性を保つための原則**:

```
原則7: "グレースフルシャットダウン"
┌─────────────────────────────────────────────┐
│                                             │
│  Cloud Runのデフォルト動作:                 │
│  1. 新リビジョンデプロイ                    │
│  2. トラフィックを新リビジョンに切り替え    │
│  3. 旧リビジョンは30秒待機                  │
│     → 実行中のリクエストを完了             │
│  4. 30秒後に旧リビジョンをシャットダウン    │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの考慮事項**:

```yaml
# timeout設定が重要
--timeout=600  # 10分

理由:
- バッチ処理（期限通知）は3分かかる
- グレースフルシャットダウンの30秒を考慮
- timeout > 処理時間 + 30秒
```

---

#### 4.2 セッションの整合性

**問題**: デプロイ時にログイン状態が失われる

```
ユーザーがログイン中
    ↓ デプロイ
セッションが旧インスタンスに保存されている
    ↓
旧インスタンスがシャットダウン
    ↓
ログアウトされる（ユーザー体験の悪化）
```

**整合性を保つための原則**:

```
原則8: "ステートレスな設計"
┌─────────────────────────────────────────────┐
│                                             │
│  けいかくんの実装:                          │
│  - JWTトークンをCookieに保存                │
│  - セッションはインスタンスに保存しない    │
│  - トークン検証はステートレス              │
│                                             │
│  → デプロイ時もログイン状態を維持          │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでの実装確認**:

```python
# ✅ ステートレス（JWTトークン）
@router.post("/api/v1/auth/login")
async def login(...):
    # トークン生成（ステートレス）
    token = create_access_token(user_id)
    response.set_cookie("access_token", token)
    return {"status": "success"}

# インスタンスに状態を保存していない
# → デプロイ時もログイン状態を維持
```

---

### 5. ロールバック可能性

#### 5.1 即座にロールバックできるか

**問題**: デプロイ後にバグが見つかったが、ロールバックできない

```
新バージョンデプロイ
    ↓
バグ発見（重大なエラー）
    ↓
ロールバック試行
    ↓
失敗（データベースマイグレーションが後戻りできない）
```

**整合性を保つための原則**:

```
原則9: "ロールバック可能な設計"
┌─────────────────────────────────────────────┐
│                                             │
│  ロールバック可能な変更:                    │
│  ✅ カラム追加（NULL許可）                  │
│  ✅ インデックス追加                        │
│  ✅ コードの変更（後方互換性あり）          │
│                                             │
│  ロールバック不可能な変更:                  │
│  ❌ カラム削除                              │
│  ❌ カラムの型変更（データ損失）            │
│  ❌ NOT NULL制約の追加（既存データが違反） │
│                                             │
└─────────────────────────────────────────────┘
```

**けいかくんでのロールバック手順**:

```bash
# Cloud Runのロールバック
# 1. リビジョン一覧を表示
gcloud run revisions list --service=k-back --region=asia-northeast1

# 2. 1つ前のリビジョンにロールバック
gcloud run services update-traffic k-back \
    --to-revisions=k-back-00002-xyz=100 \
    --region=asia-northeast1

# 3. 動作確認
curl https://keikakun-backend.run.app/api/v1/health
```

---

#### 5.2 データの整合性を保つロールバック

**問題**: ロールバック後にデータが壊れる

```
v1.0: カラムAを使用
    ↓ デプロイ（マイグレーション）
v1.1: カラムBを使用（カラムAは削除）
    ↓ バグ発見
ロールバック
    ↓
v1.0: カラムAを参照 → エラー（カラムAは存在しない）
```

**整合性を保つための原則**:

```
原則10: "前方互換性のあるマイグレーション"
┌─────────────────────────────────────────────┐
│                                             │
│  正しい手順:                                │
│  v1.0: カラムAを使用                        │
│     ↓ デプロイ（カラムBを追加）            │
│  v1.1: カラムA、Bを両方使用                │
│     ↓ データ移行                           │
│  v1.2: カラムBのみ使用（カラムAは残す）    │
│     ↓ 次回デプロイ                         │
│  v1.3: カラムA削除                         │
│                                             │
│  → どの時点でロールバックしても安全        │
│                                             │
└─────────────────────────────────────────────┘
```

---

### 6. 段階的なデプロイ

#### 6.1 カナリアデプロイ

**問題**: 全インスタンスに一度にデプロイしてバグが拡散

```
全インスタンスに新バージョンをデプロイ
    ↓
バグ発見
    ↓
全ユーザーが影響を受ける（被害甚大）
```

**整合性を保つための原則**:

```
原則11: "段階的なトラフィック移行"
┌─────────────────────────────────────────────┐
│                                             │
│  カナリアデプロイ:                          │
│  ステップ1: 新バージョンに10%のトラフィック│
│  ステップ2: 監視（5-10分）                  │
│  ステップ3: 問題なければ50%に増加          │
│  ステップ4: 監視（5-10分）                  │
│  ステップ5: 100%に移行                      │
│                                             │
└─────────────────────────────────────────────┘
```

**Cloud Runでのカナリアデプロイ**:

```bash
# 新リビジョンをデプロイ（トラフィックは0%）
gcloud run deploy k-back \
    --image=... \
    --no-traffic

# 10%のトラフィックを新リビジョンに
gcloud run services update-traffic k-back \
    --to-revisions=k-back-00003-new=10,k-back-00002-old=90

# 監視（5-10分）
# エラー率、レスポンス時間を確認

# 問題なければ100%に移行
gcloud run services update-traffic k-back \
    --to-revisions=k-back-00003-new=100
```

---

### 7. 外部サービスとの整合性

#### 7.1 NeonDBのバージョン互換性

**問題**: NeonDBの設定変更によりアプリケーションが動作しなくなる

```
アプリケーションデプロイ（新接続プール設定）
    ↓
NeonDBのMax Compute Unitsが不足
    ↓
接続エラー（全ユーザーに影響）
```

**整合性を保つための原則**:

```
原則12: "外部サービスの事前設定"
┌─────────────────────────────────────────────┐
│                                             │
│  デプロイ前:                                │
│  1. NeonDBのオートスケーリング設定を更新    │
│     - Min CU: 0.25 → 0.5                    │
│     - Max CU: 2 → 4                         │
│  2. 設定反映を確認（5分待機）               │
│  3. アプリケーションデプロイ                │
│                                             │
└─────────────────────────────────────────────┘
```

---

#### 7.2 S3との整合性

**問題**: 新しいバケットポリシーが反映されていない

```
アプリケーションデプロイ（新S3バケット使用）
    ↓
IAMポリシーが設定されていない
    ↓
S3アクセスエラー（403 Forbidden）
```

**整合性を保つための原則**:

```
原則13: "インフラ変更の事前実施"
┌─────────────────────────────────────────────┐
│                                             │
│  順序:                                      │
│  1. インフラ変更（Terraform/手動）          │
│     - S3バケット作成                        │
│     - IAMポリシー設定                       │
│  2. 設定反映確認                            │
│     - aws s3 ls でアクセス確認              │
│  3. アプリケーションデプロイ                │
│                                             │
└─────────────────────────────────────────────┘
```

---

## 🎯 けいかくん デプロイチェックリスト

### デプロイ前（1-2日前）

#### データベース関連
- [ ] マイグレーションスクリプトのレビュー
  - [ ] 後方互換性があるか（カラム追加はNULL許可）
  - [ ] ロールバック可能か（カラム削除なし）
  - [ ] 既存データに影響がないか

#### API関連
- [ ] API仕様の後方互換性を確認
  - [ ] レスポンス形式の変更なし
  - [ ] 新フィールド追加のみ（削除なし）
  - [ ] フロントエンドとの整合性確認

#### 環境変数関連
- [ ] 新しい環境変数の確認
  - [ ] GitHub Secretsに追加
  - [ ] cd-backend.ymlに追加
  - [ ] cloudbuild.ymlに追加
  - [ ] .env.exampleに追加

#### インフラ関連
- [ ] NeonDBの設定確認
  - [ ] Min/Max CUが適切か
  - [ ] Auto-suspendの設定
- [ ] Cloud Runの設定確認
  - [ ] minScale/maxScaleが適切か
  - [ ] CPU/メモリが十分か

---

### デプロイ日（本番環境）

#### デプロイ前（10分前）

- [ ] **アクセスピーク時を避ける**
  - [ ] 朝8:00-9:00を避ける
  - [ ] 推奨時刻: 10:00-17:00（平日）

- [ ] **監視体制の確認**
  - [ ] Cloud Monitoringダッシュボードを開く
  - [ ] Slackアラートチャンネルを確認
  - [ ] エラーログをリアルタイム監視

- [ ] **ロールバック準備**
  - [ ] 現在のリビジョンを確認
    ```bash
    gcloud run revisions list --service=k-back --region=asia-northeast1
    ```
  - [ ] ロールバックコマンドを準備

---

#### デプロイ実行

1. **GitHub Actionsの起動**
   ```bash
   git push origin main
   ```

2. **デプロイ進行の監視**
   - [ ] GitHub Actionsのログをリアルタイムでチェック
   - [ ] Cloud Buildのログを確認
   - [ ] Cloud Runのデプロイ状況を確認

3. **デプロイ完了確認**
   ```bash
   # 新リビジョンが100%トラフィックを受けているか確認
   gcloud run services describe k-back --region=asia-northeast1
   ```

---

#### デプロイ直後（5-10分）

- [ ] **ヘルスチェック**
  ```bash
  curl https://keikakun-backend.run.app/api/v1/health
  ```

- [ ] **主要エンドポイントの動作確認**
  - [ ] ログイン
  - [ ] 個別支援計画一覧取得
  - [ ] 個別支援計画作成
  - [ ] Googleカレンダー連携

- [ ] **エラーログの確認**
  ```bash
  gcloud run services logs read k-back \
      --region=asia-northeast1 \
      --limit=50 \
      --format=json | jq '.severity'
  ```

- [ ] **メトリクスの確認**
  - [ ] レスポンス時間（P95 < 100ms）
  - [ ] エラー率（< 0.1%）
  - [ ] CPU使用率（< 70%）
  - [ ] メモリ使用率（< 70%）

---

#### デプロイ後（1時間）

- [ ] **継続的な監視**
  - [ ] エラーログをチェック（10分ごと）
  - [ ] ユーザーからの問い合わせを確認
  - [ ] Slackアラートを監視

- [ ] **フロントエンドとの整合性確認**
  - [ ] フロントエンドで主要機能をテスト
  - [ ] ブラウザコンソールにエラーがないか確認

---

### ロールバック判断基準

以下の場合は**即座にロールバック**:

1. **エラー率 > 5%** が5分継続
2. **レスポンス時間（P95） > 1秒** が5分継続
3. **ユーザーから重大なバグ報告** が3件以上
4. **決済処理のエラー** が1件でも発生

**ロールバック手順**:
```bash
# 1つ前のリビジョンに即座に切り替え
gcloud run services update-traffic k-back \
    --to-revisions=PREVIOUS_REVISION=100 \
    --region=asia-northeast1

# 確認
curl https://keikakun-backend.run.app/api/v1/health
```

---

## 📊 デプロイ後の振り返り（翌日）

### レビュー項目

1. **デプロイは成功したか**
   - [ ] エラーなくデプロイ完了
   - [ ] ロールバックしなかった

2. **パフォーマンスは維持されたか**
   - [ ] レスポンス時間の変化を確認
   - [ ] エラー率の変化を確認

3. **想定外の問題はなかったか**
   - [ ] ユーザーからの問い合わせ
   - [ ] ログに予期しないエラー

4. **改善点はあるか**
   - [ ] デプロイ時間の短縮
   - [ ] チェックリストの改善
   - [ ] 監視項目の追加

---

## 📚 まとめ: 整合性を保つための13の原則

| 原則 | 内容 | 重要度 |
|------|------|--------|
| **原則1** | 後方互換性のあるマイグレーション | 🔴 Critical |
| **原則2** | 段階的な削除（Deprecation） | 🔴 Critical |
| **原則3** | 後方互換性のあるAPI変更 | 🔴 Critical |
| **原則4** | デプロイ順序の制御 | 🟡 High |
| **原則5** | 環境変数の事前設定 | 🟡 High |
| **原則6** | 設定ファイルの同期 | 🟡 High |
| **原則7** | グレースフルシャットダウン | 🟢 Medium |
| **原則8** | ステートレスな設計 | 🔴 Critical |
| **原則9** | ロールバック可能な設計 | 🔴 Critical |
| **原則10** | 前方互換性のあるマイグレーション | 🔴 Critical |
| **原則11** | 段階的なトラフィック移行 | 🟡 High |
| **原則12** | 外部サービスの事前設定 | 🟡 High |
| **原則13** | インフラ変更の事前実施 | 🟡 High |

---

## 🎓 教訓

### デプロイの整合性とは

```
整合性 = 稼働中のシステムを壊さずに変更を加える技術
```

**具体的には**:
1. ユーザーが気づかないうちにシステムを更新する
2. データの一貫性を保つ
3. いつでもロールバックできる状態を維持する
4. 段階的に変更を加える
5. 全てのコンポーネントが矛盾なく動作する

**成功するデプロイ** = チェックリスト × 原則の理解 × 監視

---

**作成日**: 2026-02-10
**作成者**: Claude Sonnet 4.5
**最終更新**: 2026-02-10
