# パフォーマンス要件仕様書

**Gmail期限通知バッチ処理の最適化**

---

## 📊 パフォーマンス目標

### 1. 処理時間要件

#### 基本目標

| 事業所数 | スタッフ数 | 目標時間 | 許容時間 | 現在の時間 | 改善率 |
|---------|-----------|---------|---------|-----------|--------|
| 10 | 100 | 10秒 | 30秒 | 30秒 | 3倍 |
| 100 | 1,000 | 1分 | 3分 | 5分 | 5倍 |
| 500 | 5,000 | **3分** | **5分** | 25分 | **8倍** |
| 1,000 | 10,000 | 5分 | 10分 | 50分 | 10倍 |

#### 処理時間の内訳目標

| フェーズ | 現在（500事業所） | 目標（500事業所） | 改善内容 |
|---------|-----------------|-----------------|---------|
| DBクエリ | 10秒 | 0.5秒 | バッチクエリ化 |
| データ処理 | 5秒 | 2秒 | メモリ効率化 |
| メール送信 | 1,480秒 | 177秒 | 並列処理 |
| **合計** | **1,495秒** | **179.5秒** | **8.3倍** |

---

### 2. DBクエリ効率要件

#### クエリ数の目標

**事業所数Nに対して、クエリ数がO(1)であること（定数時間）**

| 操作 | 現在のクエリ数 | 目標クエリ数 | 計算量 |
|------|--------------|-------------|--------|
| 事業所ID取得 | 1 | 1 | O(1) |
| アラート取得（更新期限） | N | 1 | O(1) |
| アラート取得（アセスメント） | N | 1 | O(1) |
| スタッフ取得 | N | 1 | O(1) |
| **合計** | **2N + 1** | **4** | **O(1)** |

#### 具体的な数値目標

| 事業所数 | 現在のクエリ数 | 目標クエリ数 | 改善率 |
|---------|--------------|-------------|--------|
| 10 | 21 | 4 | 5倍 |
| 100 | 201 | 4 | 50倍 |
| 500 | 1,001 | 4 | **250倍** |
| 1,000 | 2,001 | 4 | 500倍 |

#### クエリパフォーマンス要件

- **個別クエリ**: 10ms以下
- **バッチクエリ**: 50ms以下
- **トランザクション**: 100ms以下

---

### 3. メモリ効率要件

#### メモリ使用量の目標

| 事業所数 | 現在のメモリ | 目標メモリ | 改善率 |
|---------|------------|----------|--------|
| 10 | 10MB | 5MB | 2倍 |
| 100 | 100MB | 10MB | 10倍 |
| 500 | 500MB | **50MB** | **10倍** |
| 1,000 | 1GB | 100MB | 10倍 |

#### メモリ内訳の目標

| データ種別 | 現在（500事業所） | 目標（500事業所） | 最適化手法 |
|-----------|-----------------|-----------------|-----------|
| 事業所データ | 50MB | 5MB | 必要な列のみ取得 |
| スタッフデータ | 250MB | 25MB | チャンク処理 |
| アラートデータ | 200MB | 20MB | ストリーミング |
| **合計** | **500MB** | **50MB** | **10倍削減** |

#### メモリリーク要件

- **GC前のメモリ増加**: 50MB以下
- **GC後のメモリ保持**: 10MB以下（増加分の80%以上回収）
- **リーク検出**: パフォーマンステストで自動検出

---

### 4. 並列処理要件

#### 並列度の目標

| レベル | 現在 | 目標 | 制御方法 |
|-------|------|------|---------|
| 事業所処理 | 1（直列） | **10並列** | Semaphore(10) |
| メール送信 | 5並列 | 5並列 | Semaphore(5) |
| 合計並列度 | 5 | **50** | 階層的並列化 |

#### 並列効率

```
理論値: 500事業所 / 10並列 = 50ブロック
実測値: 処理時間が理論値の1.2倍以内

並列効率 = 理論値 / 実測値 ≥ 0.83（83%以上）
```

---

### 5. スループット要件

#### 処理速度

| メトリクス | 現在 | 目標 | 改善率 |
|-----------|------|------|--------|
| 事業所/秒 | 0.33 | **2.78** | 8倍 |
| スタッフ/秒 | 3.33 | **27.8** | 8倍 |
| メール/秒 | 3.33 | **27.8** | 8倍 |

#### レイテンシ

| 操作 | 現在 | 目標 |
|------|------|------|
| 事業所処理 | 3秒 | 0.36秒 |
| メール送信（リトライ含む） | 3秒 | 3秒（変更なし） |

---

## 🔍 測定方法

### 1. 処理時間の測定

```python
import time

start_time = time.time()
result = await send_deadline_alert_emails(db=db_session)
elapsed_time = time.time() - start_time

assert elapsed_time < 300, f"Processing time {elapsed_time}s exceeds 300s"
```

### 2. DBクエリ数の測定

```python
from sqlalchemy import event

class QueryCounter:
    def __init__(self):
        self.count = 0

    def __call__(self, conn, cursor, statement, parameters, context, executemany):
        self.count += 1

counter = QueryCounter()
event.listen(db_session.sync_session.bind, "before_cursor_execute", counter)

await send_deadline_alert_emails(db=db_session)

assert counter.count < 100, f"Query count {counter.count} exceeds 100"
```

### 3. メモリ使用量の測定

```python
import psutil
import os

process = psutil.Process(os.getpid())
memory_before = process.memory_info().rss / 1024 / 1024  # MB

await send_deadline_alert_emails(db=db_session)

memory_after = process.memory_info().rss / 1024 / 1024
memory_increase = memory_after - memory_before

assert memory_increase < 50, f"Memory increase {memory_increase}MB exceeds 50MB"
```

### 4. 並列度の測定

```python
# 処理時間から並列度を推定
total_time = elapsed_time
office_count = 500
time_per_office = total_time / office_count

# 1事業所あたり0.1秒以下なら10並列以上
estimated_parallelism = 1 / time_per_office if time_per_office > 0 else 0

assert estimated_parallelism >= 10, f"Parallelism {estimated_parallelism} < 10"
```

---

## 📈 パフォーマンステストケース

### テストケース1: 基本パフォーマンス

**目的**: 500事業所での基本性能確認

**条件**:
- 事業所数: 500
- スタッフ数: 5,000（各事業所10人）
- 利用者数: 5,000（各事業所10人）
- アラート: 各利用者1件（更新期限15日後）

**期待結果**:
- 処理時間: 5分以内
- DBクエリ数: 10以下
- メモリ使用量: 50MB以下

---

### テストケース2: クエリ効率

**目的**: N+1問題の解消確認

**条件**:
- 事業所数を10, 100, 500, 1000と変化させる
- 各事業所のデータ量は一定

**期待結果**:
- クエリ数が事業所数に比例しない（O(1)）
- 事業所数が10倍になってもクエリ数は一定

---

### テストケース3: メモリ効率

**目的**: メモリリークの検出

**条件**:
- 500事業所で処理実行
- 処理前後でGC実行

**期待結果**:
- ピークメモリ: 50MB以下
- GC後のメモリ: 増加分の80%以上回収

---

### テストケース4: 並列処理

**目的**: 並列化の効果確認

**条件**:
- 100事業所で処理実行
- 事業所あたりの処理時間を測定

**期待結果**:
- 1事業所あたり0.1秒以下
- 並列度10以上相当の性能

---

### テストケース5: エラー耐性

**目的**: 一部の事業所でエラーが発生しても全体が継続

**条件**:
- 500事業所のうち10事業所でメール送信エラー
- dry_run=False

**期待結果**:
- 490事業所は正常処理
- エラーログに10件の失敗記録
- 全体の処理は完了

---

### テストケース6: スケーラビリティ

**目的**: 1,000事業所以上での動作確認

**条件**:
- 事業所数: 1,000
- スタッフ数: 10,000

**期待結果**:
- 処理時間: 10分以内
- メモリ使用量: 100MB以下
- エラーなし

---

## 🎯 受け入れテストチェックリスト

### パフォーマンス要件

- [ ] 500事業所で5分以内に完了
- [ ] DBクエリ数が10以下
- [ ] メモリ使用量が50MB以下
- [ ] 並列度が10以上

### 機能要件

- [ ] 既存の全テストがパス
- [ ] dry_runモードが正常動作
- [ ] 監査ログが正確に記録
- [ ] エラーハンドリングが適切

### 品質要件

- [ ] コードカバレッジ85%以上
- [ ] パフォーマンステストが自動化
- [ ] メモリリーク検出テストがパス
- [ ] 負荷テストがパス

---

## 📊 ベンチマーク結果テンプレート

### 実行環境

- **OS**: Darwin 25.2.0
- **CPU**: Apple M1 Pro（8コア）
- **メモリ**: 16GB
- **Python**: 3.10
- **PostgreSQL**: 14

### 測定結果

| メトリクス | 最適化前 | 最適化後 | 改善率 | 目標達成 |
|-----------|---------|---------|--------|---------|
| 処理時間 | 1,500秒 | 180秒 | 8.3倍 | ✅ |
| DBクエリ数 | 1,001 | 4 | 250倍 | ✅ |
| メモリ使用量 | 500MB | 35MB | 14倍 | ✅ |
| 並列度 | 5 | 50 | 10倍 | ✅ |

### グラフ（イメージ）

```
処理時間（秒）
2000 |
1500 |███████████████████████  Before (1500s)
1000 |
 500 |
 180 |██ After (180s)
   0 |________________
      Before   After

      改善率: 8.3倍高速化
```

---

## 📝 備考

### パフォーマンスチューニングのポイント

1. **最優先**: N+1クエリの解消（最も効果が大きい）
2. **次に重要**: 並列処理の導入
3. **最後に**: メモリ効率化（チャンク処理）

### 継続的な最適化

- 月次でパフォーマンステスト実行
- 事業所数が増加したら再評価
- 新機能追加時にパフォーマンス影響を確認

---

**最終更新日**: 2026-02-08
**作成者**: Claude Sonnet 4.5
**承認者**: Tech Lead
