# メッセージ機能 要件定義書（自然言語版）

最終更新: 2025-11-21
作成者: 自動生成（要約）

目的
- 事務所内のスタッフ間でのメッセージ送受信と、管理者による一斉通知（お知らせ）を提供する。
- 既存のシステム通知（notices）と並行して運用できる設計とする。
- 受信者ごとの既読管理や統計（既読率）を取りやすくし、スケーラブルな一斉配信を実現する。

非機能要件
- セキュリティ: 権限チェック、XSS対策、同一事務所内の送信制限、レート制限
- パフォーマンス: 一斉通知はバルクインサートとオフラインジョブで処理し、100人〜1000人規模でも耐えられること
- 保守性: メッセージ本体と受信者情報を分離して冗長性を避け、監査や削除対応を簡単にする

主要概念（用語）
- Message: メッセージ本体（送信者・事務所・タイプ・タイトル・本文など）
- MessageRecipient: 各受信者の状態（既読/未読/アーカイブ/既読日時）を保持する中間テーブル
- MessageType: personal（個別）、announcement（お知らせ）、system（システム）、inquiry（問い合わせ）など
- MessagePriority: low/normal/high/urgent

データ設計（概要）
- messages テーブルにメッセージ本体を格納する。
- message_recipients テーブルを中間テーブルとして持ち、message_id と recipient_staff_id をキーに受信状態を管理する。
- 中間テーブルには is_read, read_at, is_archived, created_at 等のカラムを持たせる。
- 大量配信を想定し、message_recipients に対しては message_id, recipient_staff_id, is_read にインデックスを付与する。

設計上の理由
- 同じメッセージ本文を複数人で共有するため、メッセージを1レコードに集約し、受信者ごとの状態を中間テーブルで管理するとデータの重複を避けられる。
- 既読管理や統計処理を効率よく行うには中間テーブルが必須。

API 要件（エンドポイント概要）
- POST /api/v1/messages/personal
  - 個別メッセージを送信する。受信者が同じ事務所か権限をチェックする。
- POST /api/v1/messages/announcement
  - 事務所内の全スタッフへ一斉通知を送信する。オーナー等の権限チェックを行う。
- GET /api/v1/messages/inbox
  - 自分宛のメッセージ一覧を取得する。未読のみフィルタ可能。
- POST /api/v1/messages/{message_id}/read
  - 指定メッセージを既読にする（受信者本人のみ）。
- GET /api/v1/messages/{message_id}/stats
  - 送信者のみ利用可能な統計（既読数、未読数、既読率）を取得する。
- GET /api/v1/messages/unread-count
  - 通知バッジ用の未読件数を返す。

詳細な振る舞い
- エラーハンドリングや権限チェックは API 層で明確に行い、メッセージ送信時は受信者の所属事務所と送信者の所属事務所を一致させる。
- お知らせ送信はオーナーのみ許可し、送信先が存在しない場合はエラーを返す。
- API は操作が完了した際に送信したメッセージIDや受信者数を返す。

フロントエンド要件
- すでにあるnoticeページに新規タブ "メッセージ" を追加
- 受信箱UI: 時系列に並べて表示し、未読・既読の表示、既読時の即時更新（optimistic update 可）
- 受信箱ページのフィルタ: すべて / 未読のみ
- 通知センター: 既存の notices と messages を統合して時系列表示する機能を提供する
- 未読バッジ: 定期ポーリング（例: 30秒ごと）またはリアルタイムで未読件数を更新する

バルク処理とパフォーマンス
- 一斉通知の際は受信者レコードをループで1件ずつINSERT/COMMITしない（遅い）。
- 受信者レコードはまとめて作成（bulk insert / db.add_all）し、最後に一度だけコミットする。
- 大量配信（数千人）を想定する場合は、ジョブを分割して段階的にインサートする。

トランザクションとコミット管理（参考: SQLAlchemy 公式ドキュメント、SQL のアンチパターン）

目的
- データ整合性とパフォーマンスを両立させるため、適切な単位でトランザクションを分け、不要なコミットや長時間ロックを避ける。

基本方針（要点）
- 単一の論理操作は1つのトランザクションでまとめてコミットする。メッセージ送信のような「メッセージ本体 + 受信者群の作成」は一つのトランザクション単位にすることが望ましい。
- ループ内で個別にコミットするのは避ける（コミットをループ内で繰り返すと遅くなる上、部分成功・部分失敗の状態が残りやすい）。
- 大量データ処理では「チャンク単位でのトランザクション」による分割を検討する。これにより、1回の失敗が全体を巻き戻すリスクを減らし、ロック保持時間も短くできる。
- トランザクションの寿命は短く保つ。長時間のトランザクションはデッドロックやスナップショット肥大を招く。

SQLAlchemy 固有の注意点
- セッション管理はコンテキストマネージャ（例: session.begin() / async with AsyncSession.begin()）で扱い、自動的なロールバック/コミットを利用する。
- bulk系 API（bulk_save_objects, bulk_insert_mappings 等）は高速だが、ORM のイベントや関連オブジェクトの自動更新をスキップするため副作用に注意する。関係の整合性やフックが必要な場合は通常の add_all を使う。
- commit と flush の違いを理解する。flush はトランザクション内で SQL を DB に送るが、コミットするまで他トランザクションからは確定されない。必要に応じて明示的に flush してから長めの処理を行うといった運用を検討するが、乱用は避ける。
- 例外発生時は必ずセッションをロールバックしてから再利用または閉じる。IntegrityError 等を捕捉する場合でも rollback を忘れない。

よくあるアンチパターン（注意点）
- 1 件ずつコミットする（ループ内コミット）: パフォーマンスと整合性の観点から避ける。
- 長時間トランザクションで大量の行を保持する: ロック競合や WAL 増大を招く。
- ORM の bulk API を使って関連の整合性やイベントを無視する（副作用に気づかない）。
- SELECT → INSERT の一般的なチェックで楽観的に処理し、ユニーク競合を考慮しない（競合が起きる可能性がある箇所は DB 側の一意制約や INSERT ... ON CONFLICT を利用する運用を検討する）。
- 例外発生後に rollback を行わずセッションを再利用する。

メッセージ機能に対する推奨実装パターン
- 個別メッセージ（受信者数が少ない場合）
  - 一連の操作（messages の INSERT と message_recipients の INSERT群）を1トランザクションで行い、最後に commit する。
- 一斉通知（受信者が多数）
  - 受信者リストを適切なチャンク（例: 500〜2000件）に分割し、チャンクごとにトランザクションを開始して処理・コミットする。これにより単一トランザクションのサイズとロック時間を抑えられる。
  - 各チャンク内では add_all（または必要に応じて bulk_insert_mappings）でまとめて挿入し、チャンク処理完了後に一度だけコミットする。
  - 部分失敗時の取り扱いを定義する（例: 失敗チャンクをリトライ対象にする、失敗分はエラーとして記録し監査する）。
- 高頻度の未読カウント更新や既読フラグ更新
  - 単純な既読フラグは頻度が高いので、軽量な UPDATE を利用する（必要ならインデックス最適化）。大量更新であればバッチ処理や最終集計方式（イベントソーシングや集計テーブル）を検討する。

エラーハンドリングと監査
- 送信処理中の例外は詳細にログ出力し、監査ログに送信失敗を記録する。自動リトライの条件や回数は明確にする。
- DB の一意性や整合性違反は IntegrityError 等で検知できるため、これらは retry/回避ロジックと共に扱う。

チェックリスト（導入前に確認）
- [ ] commitが複数回行われていないか　
- [ ] commitはエンドポイントでのみ行っているか
- [ ] メッセージ送信の論理単位が明確にトランザクションで囲まれているか
- [ ] ループ内コミットをしていないか（もしあるならチャンク化に置き換えられるか）
- [ ] 例外時に必ずロールバックしているか
- [ ] 大量配信時のチャンクサイズとリトライ戦略が設計されているか
- [ ] async セッション（AsyncSession）を使う場合、同期的なセッションパターンを混在させていないか

参考資料
- SQLAlchemy 公式ドキュメント: Session とトランザクションの章（https://docs.sqlalchemy.org/）
- SQL アンチパターン記事（トランザクションや長期ロックに関する総説）: 検索で "transaction anti-patterns" や "long running transactions" を参照

セキュリティ要件
- 送信者／閲覧者の権限チェックを厳格に行う（同一事務所、送信者のみ統計閲覧等）。
- XSS対策: フロントエンドでは React の自動エスケープを活用し、dangerouslySetInnerHTML は基本的に使用しない。
- レート制限: 管理用途のエンドポイントや一斉送信にはレート制限を設ける（Redis またはミドルウェアを利用）。
- 個人情報・ログの取扱: 監査や通知のログに必要な情報のみ保存し、機微情報を保護する。

監査・ロギング
- メッセージ送信・既読・削除操作は監査ログに記録する（誰が、いつ、どのメッセージで操作したか）。
- 送信失敗や例外はエラーログに残す。

テスト要件
- ユニットテスト: モデル、CRUD、スキーマバリデーション
- 統合テスト（API）: 個別メッセージ送信、受信箱取得、既読化、統計取得までのフロー
- パフォーマンステスト: 一斉通知のパフォーマンス（例: 100〜1000件）を計測

運用・運用時の注意
- 大量データ保持による DB サイズ増加を考慮し、古いメッセージや受信者レコードは TTL や論理削除で定期的にクリーンアップする。
- スタッフ削除や事務所削除時の通知データの扱いを定義する（関連レコードの削除／移行ルール）。

実装スコープ（優先順）
1. messages + message_recipients テーブルと基本 CRUD
2. 個別メッセージ送信 / 受信箱 UI
3. 一斉通知（announcement）のバルク挿入実装
4. 未読バッジ・統計表示
5. notices と messages の統合表示
6. パフォーマンステストと最適化

チェックリスト（短縮）
- [ ] DB: messages, message_recipients のマイグレーション
- [ ] API: messages ルーターとエンドポイント実装
- [ ] CRUD: backend の実装とテスト
- [ ] Frontend: 受信箱、送信フォーム、未読バッジ
- [ ] Security: 権限チェック、XSS、レート制限
- [ ] Performance: バルクインサートの実装と負荷試験

関連 Issue / ドキュメント
- issue/feature-スタッフ削除機能
- issue/feature-事務所情報変更
- 既存の notices テーブル設計と利用方法の参照

備考
- このドキュメントはコードブロックや実装例を含まない自然言語の要件定義です。実装時は別途モデル定義・マイグレーション・サンプルコードを参照してください。
